// SECTION 1: MINIMAL DEPENDENCIES

use generic_array::{typenum::U16, ArrayLength};
use std::mem::{self, MaybeUninit};
use std::ops::{Deref, DerefMut};
use std::ptr;
use std::sync::atomic::{AtomicUsize, Ordering};

// --- PoC Helper Types ---

// A global counter to track drop calls.
static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);
// A global counter to track clone calls.
static CLONE_COUNTER: AtomicUsize = AtomicUsize::new(0);


#[derive(Debug)]
struct Foo {
    n: u32,
}

impl Foo {
    fn new(n: u32) -> Self {
        Self { n }
    }
}

impl Clone for Foo {
    fn clone(&self) -> Self {
        CLONE_COUNTER.fetch_add(1, Ordering::SeqCst);
        Self { n: self.n }
    }
}

impl Drop for Foo {
    fn drop(&mut self) {
        DROP_COUNTER.fetch_add(1, Ordering::SeqCst);
    }
}

// --- Minimal heapless Implementation ---

mod heapless {
    use super::{MaybeUninit, ptr};
    use super::{Deref, DerefMut};
    use generic_array;

    // Internal implementation Vec
    pub mod i {
        use super::{MaybeUninit, ptr, generic_array::{GenericArray, ArrayLength}};

        pub struct Vec<A> {
            pub(crate) buffer: MaybeUninit<A>,
            pub(crate) len: usize,
        }

        impl<A> Vec<A> {
            pub const fn new() -> Self {
                Self {
                    buffer: MaybeUninit::uninit(),
                    len: 0,
                }
            }
        }

        impl<T, N> Vec<GenericArray<T, N>> where N: ArrayLength<T>, T: Clone {
            pub fn clone(&self) -> Self {
                let mut new_vec = Self::new();
                let source_ptr = self.buffer.as_ptr() as *const T;
                let new_buffer_ptr = new_vec.buffer.as_mut_ptr() as *mut T;

                for i in 0..self.len {
                    unsafe {
                        let cloned_item = (*source_ptr.add(i)).clone();
                        ptr::write(new_buffer_ptr.add(i), cloned_item);
                    }
                }
                new_vec.len = self.len;
                new_vec
            }
        }
    }

    // Public Vec
    pub mod vec {
        use super::i;
        use super::generic_array::{GenericArray, ArrayLength};
        use super::{ptr, Deref, DerefMut};
        use std::fmt;

        #[repr(transparent)]
        pub struct Vec<T, N>(#[doc(hidden)] pub(crate) i::Vec<GenericArray<T, N>>)
        where
            N: ArrayLength<T>;

        impl<T, N> Vec<T, N>
        where
            N: ArrayLength<T>,
        {
            pub fn new() -> Self {
                Vec(i::Vec::new())
            }

            pub fn capacity(&self) -> usize {
                N::to_usize()
            }

            pub fn push(&mut self, item: T) -> Result<(), T> {
                if self.len() < self.capacity() {
                    unsafe {
                        let end = (self.0.buffer.as_mut_ptr() as *mut T).add(self.len());
                        ptr::write(end, item);
                        self.0.len += 1;
                    }
                    Ok(())
                } else {
                    Err(item)
                }
            }
        }

        impl<T, N> Clone for Vec<T, N>
        where
            N: ArrayLength<T>,
            T: Clone,
        {
            fn clone(&self) -> Self {
                Vec(self.0.clone())
            }
        }

        impl<T, N> Deref for Vec<T, N>
        where
            N: ArrayLength<T>,
        {
            type Target = [T];

            fn deref(&self) -> &Self::Target {
                unsafe {
                    std::slice::from_raw_parts(
                        self.0.buffer.as_ptr() as *const T,
                        self.0.len,
                    )
                }
            }
        }

        impl<T, N> DerefMut for Vec<T, N>
        where
            N: ArrayLength<T>,
        {
            fn deref_mut(&mut self) -> &mut Self::Target {
                unsafe {
                    std::slice::from_raw_parts_mut(
                        self.0.buffer.as_mut_ptr() as *mut T,
                        self.0.len,
                    )
                }
            }
        }

        pub struct IntoIter<T, N>
        where
            N: ArrayLength<T>,
        {
            // Fields are pub(crate) to be accessible within the `heapless` module
            pub(crate) vec: Vec<T, N>,
            pub(crate) next: usize,
        }

        impl<T, N> Iterator for IntoIter<T, N>
        where
            N: ArrayLength<T>,
        {
            type Item = T;
            fn next(&mut self) -> Option<Self::Item> {
                if self.next < self.vec.len() {
                    let item = unsafe {
                        (self.vec.0.buffer.as_ptr() as *const T)
                            .add(self.next)
                            .read()
                    };
                    self.next += 1;
                    Some(item)
                } else {
                    None
                }
            }
        }

        impl<T, N> Drop for IntoIter<T, N>
        where
            N: ArrayLength<T>,
        {
            fn drop(&mut self) {
                unsafe {
                    ptr::drop_in_place(&mut self.vec[self.next..]);
                    self.vec.0.len = 0;
                }
            }
        }

        impl<T, N> IntoIterator for Vec<T, N>
        where
            N: ArrayLength<T>,
        {
            type Item = T;
            type IntoIter = IntoIter<T, N>;

            fn into_iter(self) -> Self::IntoIter {
                IntoIter { vec: self, next: 0 }
            }
        }

        impl<T, N> fmt::Debug for Vec<T, N>
        where
            T: fmt::Debug,
            N: ArrayLength<T>,
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                <[T] as fmt::Debug>::fmt(self, f)
            }
        }

        // SECTION 2: VULNERABLE CODE
        impl<T, N> Clone for IntoIter<T, N>
        where
            T: Clone,
            N: ArrayLength<T>,
        {
            fn clone(&self) -> Self {
                Self {
                    vec: self.vec.clone(),
                    next: self.next,
                }
            }
        }
    }
}

use heapless::vec::Vec;

// SECTION 3: PROOF-OF-CONCEPT

fn main() {
    // 1. Setup the vector and iterator.
    let mut v: Vec<Foo, U16> = Vec::new();
    v.push(Foo::new(1)).unwrap();
    v.push(Foo::new(2)).unwrap();
    v.push(Foo::new(3)).unwrap();
    let mut i = v.into_iter();

    // 2. Consume and drop the first item, creating a "hole" in the iterator's memory.
    let item = i.next();
    mem::drop(item);
    assert_eq!(DROP_COUNTER.load(Ordering::SeqCst), 1);

    // 3. Vulnerable clone reads from the "hole" (Use-After-Free).
    let j = i.clone();

    // The dropped item was cloned again, reading its freed memory.
    assert_eq!(CLONE_COUNTER.load(Ordering::SeqCst), 2);
}