// SECTION 1: MINIMAL DEPENDENCIES

use std::mem::{self, ManuallyDrop};
use std::ops::{Deref, DerefMut};
use std::ptr;
use std::slice;

/// Types that can be used as the backing store for a SmallVec
pub unsafe trait Array {
    type Item;
    fn size() -> usize;
    fn ptr(&self) -> *const Self::Item;
    fn ptr_mut(&mut self) -> *mut Self::Item;
}

macro_rules! impl_array {
    ($($size:expr),+) => {
        $(
            unsafe impl<T> Array for [T; $size] {
                type Item = T;
                fn size() -> usize { $size }
                fn ptr(&self) -> *const T { self.as_ptr() }
                fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }
            }
        )+
    }
}

impl_array!(0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 32, 64);

union SmallVecData<A: Array> {
    inline: ManuallyDrop<A>,
    heap: (*mut A::Item, usize),
}

impl<A: Array> SmallVecData<A> {
    unsafe fn from_inline(inline: A) -> Self {
        SmallVecData {
            inline: ManuallyDrop::new(inline),
        }
    }
    unsafe fn from_heap(ptr: *mut A::Item, len: usize) -> Self {
        SmallVecData { heap: (ptr, len) }
    }
    unsafe fn inline(&self) -> &A {
        &self.inline
    }
    unsafe fn inline_mut(&mut self) -> &mut A {
        &mut self.inline
    }
    unsafe fn heap(&self) -> (*mut A::Item, usize) {
        self.heap
    }
    unsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize) {
        &mut self.heap
    }
}

pub struct SmallVec<A: Array> {
    capacity: usize,
    data: SmallVecData<A>,
}

unsafe fn deallocate<T>(ptr: *mut T, capacity: usize) {
    let _vec: Vec<T> = Vec::from_raw_parts(ptr, 0, capacity);
}

impl<A: Array> SmallVec<A> {
    #[inline]
    pub fn new() -> SmallVec<A> {
        unsafe {
            SmallVec {
                capacity: 0,
                data: SmallVecData::from_inline(mem::MaybeUninit::uninit().assume_init()),
            }
        }
    }

    #[inline]
    pub fn len(&self) -> usize {
        self.triple().1
    }

    #[inline]
    pub fn capacity(&self) -> usize {
        self.triple().2
    }

    #[inline]
    pub fn spilled(&self) -> bool {
        self.capacity > A::size()
    }

    #[inline]
    pub fn inline_size(&self) -> usize {
        A::size()
    }

    #[inline]
    fn triple(&self) -> (*const A::Item, usize, usize) {
        unsafe {
            if self.spilled() {
                let (ptr, len) = self.data.heap();
                (ptr, len, self.capacity)
            } else {
                (self.data.inline().ptr(), self.capacity, A::size())
            }
        }
    }

    #[inline]
    fn triple_mut(&mut self) -> (*mut A::Item, &mut usize, usize) {
        unsafe {
            if self.spilled() {
                let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();
                (ptr, len_ptr, self.capacity)
            } else {
                (self.data.inline_mut().ptr_mut(), &mut self.capacity, A::size())
            }
        }
    }

    pub fn push(&mut self, element: A::Item) {
        let (len, cap) = (self.len(), self.capacity());
        if len == cap {
            self.grow_one();
        }
        unsafe {
            let (ptr, len_ptr, _) = self.triple_mut();
            ptr::write(ptr.add(len), element);
            *len_ptr = len + 1;
        }
    }

    #[cold]
    fn grow_one(&mut self) {
        let cap = self.capacity();
        let new_cap = if cap == 0 { 4 } else { cap * 2 };
        let (ptr, len, _) = self.triple_mut();
        let current_len = *len;
        unsafe {
            let mut new_v = Vec::with_capacity(new_cap);
            let new_ptr = new_v.as_mut_ptr();
            mem::forget(new_v);
            ptr::copy_nonoverlapping(ptr, new_ptr, current_len);
            if self.spilled() {
                deallocate(ptr, cap);
            }
            self.data = SmallVecData::from_heap(new_ptr, current_len);
            self.capacity = new_cap;
        }
    }
}

impl<A: Array> Drop for SmallVec<A> {
    fn drop(&mut self) {
        unsafe {
            if self.spilled() {
                let (ptr, len) = self.data.heap();
                drop(Vec::from_raw_parts(ptr, len, self.capacity));
            } else {
                ptr::drop_in_place(&mut self[..]);
            }
        }
    }
}

impl<A: Array> Deref for SmallVec<A> {
    type Target = [A::Item];
    #[inline]
    fn deref(&self) -> &[A::Item] {
        let (ptr, len, _) = self.triple();
        unsafe { slice::from_raw_parts(ptr, len) }
    }
}

impl<A: Array> DerefMut for SmallVec<A> {
    #[inline]
    fn deref_mut(&mut self) -> &mut [A::Item] {
        let (ptr, len, _) = self.triple_mut();
        unsafe { slice::from_raw_parts_mut(ptr, *len) }
    }
}

// SECTION 2: VULNERABLE CODE

impl<A: Array> SmallVec<A> {
    /// Re-allocate to set the capacity to `max(new_cap, inline_size())`.
    ///
    /// Panics if `new_cap` is less than the vector's length.
    pub fn grow(&mut self, new_cap: usize) {
        unsafe {
            let (ptr, &mut len, cap) = self.triple_mut();
            let unspilled = !self.spilled();
            assert!(new_cap >= len);
            if new_cap <= self.inline_size() {
                if unspilled {
                    return;
                }
                self.data = SmallVecData::from_inline(mem::MaybeUninit::uninit().assume_init());
                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
            } else if new_cap != cap {
                let mut vec = Vec::with_capacity(new_cap);
                let new_alloc = vec.as_mut_ptr();
                mem::forget(vec);
                ptr::copy_nonoverlapping(ptr, new_alloc, len);
                self.data = SmallVecData::from_heap(new_alloc, len);
                self.capacity = new_cap;
                if unspilled {
                    return;
                }
            }
            deallocate(ptr, cap);
        }
    }
}


// SECTION 3: PROOF-OF-CONCEPT

fn main() {
    // 1. Setup a SmallVec with inline capacity of 2.
    let mut v: SmallVec<[u8; 2]> = SmallVec::new();
    v.push(0);
    v.push(1);
    assert_eq!(&v[..], &[0, 1]);
    assert!(!v.spilled());

    // 2. Cause it to spill from inline storage to the heap by pushing a 3rd element.
    // The new capacity will be 4.
    v.push(2);
    assert_eq!(&v[..], &[0, 1, 2]);

    // 3. Trigger BUG: call `grow` with the current capacity (4).
    // The vulnerable code falls through to `deallocate`, freeing the heap buffer.
    v.grow(4);
    assert_eq!(&v[..], &[0, 1, 2]);
}