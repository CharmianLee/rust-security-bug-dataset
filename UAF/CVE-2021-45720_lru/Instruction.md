Instruction.md

## Dependencies:(omissible)
- Crates:
  - `std`
- Modules:
  - `std::collections`
  - `std::marker`
  - `std::hash`
  - `std::mem`
  - `std::ptr`
  - `std::borrow`
  - `std::fmt`
- Types:
  - Structs: `LruCache`, `LruEntry`, `KeyRef`, `Iter`, `HashMap`, `Box`, `PhantomData`, `MaybeUninit`
  - Enums: `Option`
  - Primitive Types: `usize`, `*mut T`, `*const T`, `i32`
  - Type Alias: `DefaultHasher`
- Traits:
  - `Hash`, `Eq`, `PartialEq`, `BuildHasher`, `Hasher`, `Borrow`, `Iterator`, `Drop`, `FusedIterator`
- Functions and Methods:
  - Associated Functions: `LruCache::new`
  - Methods: `LruCache::put`, `LruCache::pop`, `LruCache::iter`, `String::from`, `String::clone`, `String::len`

## Vulnerable Code:
```rust
// Located in `impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S>`
pub fn iter<'a>(&'_ self) -> Iter<'a, K, V> {
    Iter {
        len: self.len(),
        ptr: unsafe { (*self.head).next },
        end: unsafe { (*self.tail).prev },
        phantom: PhantomData,
    }
}
```

## Trigger Method:(based)
```rust
fn main() {
    let mut cache = LruCache::new(100);

    cache.put(1, String::from("Hello world"));
    cache.put(2, String::from("How are you?"));
    cache.put(3, String::from("It's a great day!"));

    for (key, value) in cache.iter() {
        let value_before_pop = value.clone();
        
        // This call is allowed due to the incorrect lifetime on `iter`,
        // but it invalidates the `value` reference. In a patched version,
        // this would cause a compile-time borrow checker error.
        cache.pop(key);

        // This accesses the dangling pointer `value`, triggering Use-After-Free.
        // The assertion might fail with a panic due to reading corrupted
        // memory, or the program might crash.
        assert_eq!(value_before_pop.len(), value.len());
    }
}
```