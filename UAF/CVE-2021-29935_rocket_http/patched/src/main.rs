// SECTION 1: MINIMAL DEPENDENCIES

use smallvec::SmallVec;
use std::fmt::{self, Write};
use std::marker::PhantomData;
use std::panic;

// --- Trait and Type definitions from the original crate ---

mod private {
    pub trait Sealed {}
}

pub trait UriPart: private::Sealed {
    const DELIMITER: char;
}

#[derive(Debug, Clone, Copy)]
pub enum Query {}

impl private::Sealed for Query {}

impl UriPart for Query {
    const DELIMITER: char = '&';
}

pub trait UriDisplay<P: UriPart> {
    fn fmt(&self, f: &mut Formatter<'_, P>) -> fmt::Result;
}

impl<P: UriPart> fmt::Display for &dyn UriDisplay<P> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        UriDisplay::fmt(*self, &mut Formatter::new(f))
    }
}

pub struct Formatter<'i, P: UriPart> {
    prefixes: SmallVec<[&'static str; 3]>,
    inner: &'i mut (dyn Write + 'i),
    previous: bool,
    fresh: bool,
    _marker: PhantomData<P>,
}

impl<'i, P: UriPart> Formatter<'i, P> {
    #[inline(always)]
    fn new(inner: &'i mut (dyn Write + 'i)) -> Self {
        Formatter {
            inner,
            prefixes: SmallVec::new(),
            previous: false,
            fresh: true,
            _marker: PhantomData,
        }
    }

    #[inline(always)]
    fn refreshed<F: FnOnce(&mut Self) -> fmt::Result>(&mut self, f: F) -> fmt::Result {
        self.refresh();
        let result = f(self);
        self.refresh();
        result
    }

    pub fn write_raw<S: AsRef<str>>(&mut self, string: S) -> fmt::Result {
        if self.fresh && P::DELIMITER == '&' {
            if self.previous {
                self.inner.write_char(P::DELIMITER)?;
            }

            if !self.prefixes.is_empty() {
                for (i, prefix) in self.prefixes.iter().enumerate() {
                    self.inner.write_str(prefix)?;
                    if i < self.prefixes.len() - 1 {
                        self.inner.write_str(".")?;
                    }
                }
                self.inner.write_str("=")?;
            }
        }

        self.fresh = false;
        self.previous = true;
        self.inner.write_str(string.as_ref())
    }

    #[inline]
    pub fn write_value<T: UriDisplay<P>>(&mut self, value: T) -> fmt::Result {
        self.refreshed(|f| UriDisplay::fmt(&value, f))
    }

    #[inline(always)]
    pub fn refresh(&mut self) {
        self.fresh = true;
    }
}

// SECTION 2: PATCHED CODE

impl<'i> Formatter<'i, Query> {
    fn with_prefix<F>(&mut self, prefix: &str, f: F) -> fmt::Result
    where F: FnOnce(&mut Self) -> fmt::Result
    {
        struct PrefixGuard<'f, 'i>(&'f mut Formatter<'i, Query>);

        impl<'f, 'i> PrefixGuard<'f, 'i> {
            fn new(prefix: &str, f: &'f mut Formatter<'i, Query>) -> Self {
                let prefix = unsafe { std::mem::transmute(prefix) };
                f.prefixes.push(prefix);
                PrefixGuard(f)
            }
        }

        impl Drop for PrefixGuard<'_, '_> {
            fn drop(&mut self) {
                self.0.prefixes.pop();
            }
        }

        f(&mut PrefixGuard::new(prefix, self).0)
    }

    #[inline]
    pub fn write_named_value<T: UriDisplay<Query>>(&mut self, name: &str, value: T) -> fmt::Result {
        self.refreshed(|f| f.with_prefix(name, |f| f.write_value(value)))
    }
}


// SECTION 3: PROOF-OF-CONCEPT

// A type that panics when formatted.
struct MyValue;
impl UriDisplay<Query> for MyValue {
    fn fmt(&self, _f: &mut Formatter<Query>) -> fmt::Result {
        panic!("controlled panic to trigger bug")
    }
}

// A wrapper to control drop order and memory layout.
struct Wrapper<'a, 'b>(&'a mut Formatter<'b, Query>);
impl<'a, 'b> Drop for Wrapper<'a, 'b> {
    fn drop(&mut self) {
        // This string allocates over the memory of `temporary_string` ("hello") from `MyDisplay::fmt`.
        let _reused_memory_string = String::from("12345");
        // This call will now use the formatter with its prefixes correctly managed.
        self.0.write_raw("world").ok();
    }
}

// A type that sets up the conditions for the UAF.
struct MyDisplay;
impl UriDisplay<Query> for MyDisplay {
    fn fmt(&self, formatter: &mut Formatter<Query>) -> fmt::Result {
        // The wrapper ensures its `drop` is called during panic-unwinding.
        let wrapper = Wrapper(formatter);
        // This string's memory will be pointed to by the dangling pointer.
        let temporary_string = String::from("hello");
        // This call pushes a pointer to `temporary_string` into the formatter, then panics.
        wrapper.0.write_named_value(&temporary_string, MyValue)
    }
}

fn main() {
    let mut buffer = String::new();
    let mut formatter = Formatter::<Query>::new(&mut buffer);

    let poc_trigger = MyDisplay;

    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        UriDisplay::fmt(&poc_trigger, &mut formatter)
    }));

    assert!(result.is_err());

    // NOTE: With the patch applied, the UAF is prevented. The `PrefixGuard`
    // ensures the dangling pointer is removed from `prefixes` during the panic.
    // As a result, the buffer will contain "world" instead of the exploited "12345=world".
    // The following assertion will now FAIL, which demonstrates the patch is effective.
    println!("Patched code executed. Buffer content is now: \"{}\"", buffer);
    println!("The assertion `assert_eq!(buffer, \"12345=world\")` will now fail, proving the fix.");

    assert_eq!(buffer, "12345=world");
}