// SECTION 1: MINIMAL DEPENDENCIES

use bitflags::bitflags;
use libc::{c_int, c_uint, c_void};
use std::marker::PhantomData;
use std::ptr;
use std::sync::atomic::{AtomicBool, Ordering};

// --- Mocked FFI Layer ---

static BIO_FREED: AtomicBool = AtomicBool::new(false);
const MOCK_BIO_PTR: *mut ffi::BIO = 1 as *mut _;
const MOCK_CMS_PTR: *mut ffi::CMS_ContentInfo = 1 as *mut _;

#[allow(non_camel_case_types, non_snake_case)]
mod ffi {
    use super::*;

    // Opaque types
    pub enum BIO {}
    pub enum CMS_ContentInfo {}
    pub enum X509 {}
    pub enum EVP_PKEY {}
    pub enum stack_st_X509 {}

    // FFI function mocks
    pub unsafe fn BIO_new_mem_buf(_buf: *const c_void, _len: c_int) -> *mut BIO {
        MOCK_BIO_PTR
    }

    pub unsafe fn BIO_free_all(_bio: *mut BIO) {
        BIO_FREED.store(true, Ordering::Relaxed);
    }

    pub unsafe fn CMS_sign(
        _signcert: *mut X509,
        _pkey: *mut EVP_PKEY,
        _certs: *mut stack_st_X509,
        data: *mut BIO,
        _flags: c_uint,
    ) -> *mut CMS_ContentInfo {
        // This is the use-after-free point.
        // We assert that the BIO has not been freed. The vulnerable code
        // will cause this assertion to fail.
        assert!(
            !BIO_FREED.load(Ordering::Relaxed),
            "PANIC: Use-After-Free detected! Attempted to use a BIO pointer after it was freed."
        );
        // If data is not null, it means we are using it.
        if !data.is_null() {
            // In a real scenario, this would be a read/write to dangling pointer.
        }
        MOCK_CMS_PTR
    }
}

// --- Minimal Rust-level Wrappers ---

#[derive(Debug)]
pub struct ErrorStack;

impl ErrorStack {
    fn get() -> Self {
        ErrorStack
    }
}

fn cvt_p<T>(r: *mut T) -> Result<*mut T, ErrorStack> {
    if r.is_null() {
        Err(ErrorStack::get())
    } else {
        Ok(r)
    }
}

// Key struct causing the UAF
pub struct MemBioSlice<'a>(*mut ffi::BIO, PhantomData<&'a [u8]>);

impl<'a> MemBioSlice<'a> {
    pub fn new(buf: &'a [u8]) -> Result<MemBioSlice<'a>, ErrorStack> {
        let bio = unsafe {
            cvt_p(ffi::BIO_new_mem_buf(
                buf.as_ptr() as *const _,
                buf.len() as c_int,
            ))?
        };
        Ok(MemBioSlice(bio, PhantomData))
    }

    pub fn as_ptr(&self) -> *mut ffi::BIO {
        self.0
    }
}

impl<'a> Drop for MemBioSlice<'a> {
    fn drop(&mut self) {
        unsafe {
            ffi::BIO_free_all(self.0);
        }
    }
}

// Other required types for the function signature
pub struct CmsContentInfo(*mut ffi::CMS_ContentInfo);

impl CmsContentInfo {
    pub fn from_ptr(ptr: *mut ffi::CMS_ContentInfo) -> Self {
        CmsContentInfo(ptr)
    }
}

pub struct X509(*mut ffi::X509);
impl X509 {
    fn as_ptr(&self) -> *mut ffi::X509 {
        self.0
    }
}

pub struct PKey<T>(*mut ffi::EVP_PKEY, PhantomData<T>);
impl<T> PKey<T> {
    fn as_ptr(&self) -> *mut ffi::EVP_PKEY {
        self.0
    }
}

pub struct Stack<T>(*mut ffi::stack_st_X509, PhantomData<T>);
impl<T> Stack<T> {
    fn as_ptr(&self) -> *mut ffi::stack_st_X509 {
        self.0
    }
}

bitflags! {
    pub struct CMSOptions: c_uint {
        // We don't need the actual values for the PoC
    }
}

pub unsafe trait HasPrivate {}
pub enum Private {}
unsafe impl HasPrivate for Private {}

// SECTION 2: VULNERABLE CODE

impl CmsContentInfo {
    /// Given a signing cert `signcert`, private key `pkey`, a certificate stack `certs`,
    /// data `data` and flags `flags`, create a CmsContentInfo struct.
    ///
    /// All arguments are optional.
    ///
    /// OpenSSL documentation at [`CMS_sign`]
    ///
    /// [`CMS_sign`]: https://www.openssl.org/docs/manmaster/man3/CMS_sign.html
    pub fn sign<T: HasPrivate>(
        signcert: Option<&X509>,
        pkey: Option<&PKey<T>>,
        certs: Option<&Stack<X509>>,
        data: Option<&[u8]>,
        flags: CMSOptions,
    ) -> Result<CmsContentInfo, ErrorStack> {
        unsafe {
            let signcert = match signcert {
                Some(cert) => cert.as_ptr(),
                None => ptr::null_mut(),
            };
            let pkey = match pkey {
                Some(pkey) => pkey.as_ptr(),
                None => ptr::null_mut(),
            };
            let data_bio_ptr = match data {
                Some(data) => MemBioSlice::new(data)?.as_ptr(),
                None => ptr::null_mut(),
            };
            let certs = match certs {
                Some(certs) => certs.as_ptr(),
                None => ptr::null_mut(),
            };

            let cms = cvt_p(ffi::CMS_sign(
                signcert,
                pkey,
                certs,
                data_bio_ptr,
                flags.bits(),
            ))?;

            Ok(CmsContentInfo::from_ptr(cms))
        }
    }
}

// SECTION 3: PROOF-OF-CONCEPT

fn main() {
    println!("Triggering Use-After-Free vulnerability...");
    println!("The program is expected to panic if the vulnerability is present.");

    // This call will panic inside our mocked `ffi::CMS_sign` function.
    // 1. `MemBioSlice::new` is called, a mock BIO is created.
    // 2. The `MemBioSlice` is a temporary that lives only inside the `match` arm.
    // 3. When the `match` arm finishes, the `MemBioSlice` is dropped.
    // 4. `MemBioSlice::drop` calls our mock `ffi::BIO_free_all`, setting `BIO_FREED` to true.
    // 5. The dangling `data_bio_ptr` is passed to `ffi::CMS_sign`.
    // 6. `ffi::CMS_sign` asserts that `BIO_FREED` is false, which fails and causes a panic.
    let _ = CmsContentInfo::sign::<Private>(
        None,
        None,
        None,
        Some(b"some data"),
        CMSOptions::empty(),
    );

    println!("If you see this message, the vulnerability was not triggered.");
}