// SECTION 1: MINIMAL DEPENDENCIES

use bitflags::bitflags;
use libc::{c_int, c_uint, c_void};
use std::marker::PhantomData;
use std::ptr;
use std::sync::atomic::{AtomicBool, Ordering};

// --- Mocked FFI Layer ---

static BIO_FREED: AtomicBool = AtomicBool::new(false);
const MOCK_BIO_PTR: *mut ffi::BIO = 1 as *mut _;
const MOCK_CMS_PTR: *mut ffi::CMS_ContentInfo = 1 as *mut _;

#[allow(non_camel_case_types, non_snake_case)]
mod ffi {
    use super::*;

    // Opaque types
    pub enum BIO {}
    pub enum CMS_ContentInfo {}
    pub enum X509 {}
    pub enum EVP_PKEY {}
    pub enum stack_st_X509 {}

    // FFI function mocks
    pub unsafe fn BIO_new_mem_buf(_buf: *const c_void, _len: c_int) -> *mut BIO {
        MOCK_BIO_PTR
    }

    pub unsafe fn BIO_free_all(_bio: *mut BIO) {
        BIO_FREED.store(true, Ordering::Relaxed);
    }

    pub unsafe fn CMS_sign(
        _signcert: *mut X509,
        _pkey: *mut EVP_PKEY,
        _certs: *mut stack_st_X509,
        data: *mut BIO,
        _flags: c_uint,
    ) -> *mut CMS_ContentInfo {
        // This assertion remains to prove the fix.
        // In the patched version, this should NOT panic because BIO_FREED is still false.
        assert!(
            !BIO_FREED.load(Ordering::Relaxed),
            "PANIC: Use-After-Free detected! Attempted to use a BIO pointer after it was freed."
        );
        // If data is not null, it means we are using it.
        if !data.is_null() {
            // In a real scenario, this would be a read/write to a valid pointer.
        }
        MOCK_CMS_PTR
    }
}

// --- Minimal Rust-level Wrappers ---

#[derive(Debug)]
pub struct ErrorStack;

impl ErrorStack {
    fn get() -> Self {
        ErrorStack
    }
}

fn cvt_p<T>(r: *mut T) -> Result<*mut T, ErrorStack> {
    if r.is_null() {
        Err(ErrorStack::get())
    } else {
        Ok(r)
    }
}

// Key struct causing the UAF
pub struct MemBioSlice<'a>(*mut ffi::BIO, PhantomData<&'a [u8]>);

impl<'a> MemBioSlice<'a> {
    pub fn new(buf: &'a [u8]) -> Result<MemBioSlice<'a>, ErrorStack> {
        let bio = unsafe {
            cvt_p(ffi::BIO_new_mem_buf(
                buf.as_ptr() as *const _,
                buf.len() as c_int,
            ))?
        };
        Ok(MemBioSlice(bio, PhantomData))
    }

    pub fn as_ptr(&self) -> *mut ffi::BIO {
        self.0
    }
}

impl<'a> Drop for MemBioSlice<'a> {
    fn drop(&mut self) {
        unsafe {
            ffi::BIO_free_all(self.0);
        }
    }
}

// Other required types for the function signature
pub struct CmsContentInfo(*mut ffi::CMS_ContentInfo);

impl CmsContentInfo {
    pub fn from_ptr(ptr: *mut ffi::CMS_ContentInfo) -> Self {
        CmsContentInfo(ptr)
    }
}

pub struct X509(*mut ffi::X509);
impl X509 {
    fn as_ptr(&self) -> *mut ffi::X509 {
        self.0
    }
}

pub struct PKey<T>(*mut ffi::EVP_PKEY, PhantomData<T>);
impl<T> PKey<T> {
    fn as_ptr(&self) -> *mut ffi::EVP_PKEY {
        self.0
    }
}

pub struct Stack<T>(*mut ffi::stack_st_X509, PhantomData<T>);
impl<T> Stack<T> {
    fn as_ptr(&self) -> *mut ffi::stack_st_X509 {
        self.0
    }
}

bitflags! {
    pub struct CMSOptions: c_uint {
        // We don't need the actual values for the PoC
    }
}

pub unsafe trait HasPrivate {}
pub enum Private {}
unsafe impl HasPrivate for Private {}

// SECTION 2: PATCHED CODE

impl CmsContentInfo {
    pub fn sign<T: HasPrivate>(
        signcert: Option<&X509>,
        pkey: Option<&PKey<T>>,
        certs: Option<&Stack<X509>>,
        data: Option<&[u8]>,
        flags: CMSOptions,
    ) -> Result<CmsContentInfo, ErrorStack> {
        unsafe {
            let signcert = signcert.map_or(ptr::null_mut(), |p| p.as_ptr());
            let pkey = pkey.map_or(ptr::null_mut(), |p| p.as_ptr());

            // The fix: Bind the MemBioSlice to a variable to extend its lifetime.
            let data_bio = match data {
                Some(data) => Some(MemBioSlice::new(data)?),
                None => None,
            };
            let data_bio_ptr = data_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());

            let certs = certs.map_or(ptr::null_mut(), |p| p.as_ptr());

            let cms = cvt_p(ffi::CMS_sign(
                signcert,
                pkey,
                certs,
                data_bio_ptr,
                flags.bits(),
            ))?;

            Ok(CmsContentInfo::from_ptr(cms))
        } // `data_bio` is dropped here, AFTER ffi::CMS_sign has finished.
    }
}


// SECTION 3: PROOF-OF-CONCEPT

fn main() {
    println!("Testing the patched version...");

    // This call should now succeed without panicking.
    let result = CmsContentInfo::sign::<Private>(
        None,
        None,
        None,
        Some(b"some data"),
        CMSOptions::empty(),
    );

    // Assert that the call was successful and did not panic.
    assert!(result.is_ok(), "The sign function returned an error.");

    // We can also check the state of our mock flag.
    // The `BIO_FREED` flag should be true now, because the `sign` function
    // has completed and the `data_bio` variable was dropped.
    assert!(BIO_FREED.load(Ordering::Relaxed), "The BIO was not freed after the call, which is unexpected.");

    println!("The patched code executed successfully without Use-After-Free.");
}