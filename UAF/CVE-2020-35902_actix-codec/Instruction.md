## Dependencies:
- Crates:
  - `bitflags = "1.2"`
  - `bytes = "0.5"`
  - `futures = "0.3"`
  - `futures-core = "0.3"`
  - `futures-sink = "0.3"`
  - `pin-project = "1.0"`
  - `tokio = { version = "0.2", features = ["io-util"] }`
- Modules:
  - `std::future::Future`
  - `std::io`
  - `std::marker::Unpin`
  - `std::mem`
  - `std::pin::Pin`
  - `std::task::{Context, Poll}`
  - `bytes::{Bytes, BytesMut}`
  - `futures::channel::oneshot`
  - `futures::task::noop_waker`
  - `pin_project::pin_project`
  - `tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite}`
- Types:
  - Structs: `Framed`, `BytesCodec`, `FakeSocket`, `BytesMut`, `Bytes`
  - Enums: `Poll`, `Result`, `Option`
- Traits:
  - `Decoder`
  - `Encoder`
  - `Future`
  - `AsyncRead`
  - `AsyncWrite`
  - `Unpin`
- Functions and Methods:
  - Associated Functions: `Framed::new`, `Context::from_waker`, `futures::channel::oneshot::channel`
  - Methods: `Framed::next_item`, `mem::replace`, `noop_waker`, `sender.send`, `receiver.await`
- Macros:
  - `bitflags!`
  - `pin_project!`

## Vulnerable Code:
```rust
impl<T, U> Framed<T, U> {
    pub fn next_item(&mut self, cx: &mut Context<'_>) -> Poll<Option<Result<U::Item, U::Error>>>
    where
        T: AsyncRead,
        U: Decoder,
    {
        loop {
            // ... (code omitted for brevity) ...

            // Otherwise, try to read more data and try again. Make sure we've got room
            let remaining = self.read_buf.capacity() - self.read_buf.len();
            if remaining < 1024 { // LW
                self.read_buf.reserve(8192 - remaining) // HW
            }
            let cnt = match unsafe {
                Pin::new_unchecked(&mut self.io).poll_read_buf(cx, &mut self.read_buf)
            } {
                Poll::Pending => return Poll::Pending,
                Poll::Ready(Err(e)) => return Poll::Ready(Some(Err(e.into()))),
                Poll::Ready(Ok(cnt)) => cnt,
            };

            if cnt == 0 {
                self.flags.insert(Flags::EOF);
            }
            self.flags.insert(Flags::READABLE);
        }
    }
}
```

## Trigger Method:
```rust
fn main() {
  let (wake_tx, wake_rx) = oneshot::channel::<()>();
  let (result_tx, mut result_rx) = oneshot::channel::<u64>();

  const ORIGINAL_PATTERN: u64 = 0xFEEDBEEF_CAFEBABE;
  const CORRUPTING_BYTE: u8 = 0x41; // 'A'
  const CORRUPTING_PATTERN: u64 = u64::from_ne_bytes([CORRUPTING_BYTE; 8]);
  const CORRUPTING_BYTE_ARRAY: [u8; 32] = [CORRUPTING_BYTE; 32];

  let mut framed: Result<_, [u8; 32]> = Ok(Framed::new(
    FakeSocket {
      inner: async move {
        let original_data = ORIGINAL_PATTERN.to_ne_bytes();
        let y_ptr = &original_data as *const _ as *const u64;
        let _ = wake_rx.await;
        let corrupted_value = unsafe { *y_ptr };
        let _ = result_tx.send(corrupted_value);
      },
    },
    BytesCodec,
  ));

  let waker = noop_waker();
  let mut context = Context::from_waker(&waker);

  // This is the line that will now fail to compile.
  let _ = framed.as_mut().unwrap().next_item(&mut context);

  let mut moved_framed = mem::replace(&mut framed, Err(CORRUPTING_BYTE_ARRAY)).unwrap();
  wake_tx.send(()).unwrap();
  let _ = moved_framed.next_item(&mut context);

  let value_after_uaf = result_rx
          .try_recv()
          .expect("Receiver should not be canceled")
          .expect("Future should have sent a value");

  println!("This line should not be reached.");
  assert_eq!(value_after_uaf, CORRUPTING_PATTERN);
}
```