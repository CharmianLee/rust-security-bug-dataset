// SECTION 1: MINIMAL DEPENDENCIES (Identical to vulnerable version)

use bitflags::bitflags;
use bytes::{Buf, BufMut, Bytes, BytesMut};
use futures::channel::oneshot;
use futures::task::{noop_waker, Context, Poll};
use pin_project::pin_project;
use std::future::Future;
use std::io;
use std::mem;
use std::pin::Pin;
use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite};

pub trait Encoder<I> {
    type Error: From<io::Error>;
    fn encode(&mut self, item: I, dst: &mut BytesMut) -> Result<(), Self::Error>;
}
pub trait Decoder {
    type Item;
    type Error: From<io::Error>;
    fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error>;
    fn decode_eof(&mut self, buf: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
        match self.decode(buf)? {
            Some(frame) => Ok(Some(frame)),
            None => {
                if buf.is_empty() {
                    Ok(None)
                } else {
                    self.decode(buf)
                }
            }
        }
    }
}

#[derive(Debug, Copy, Clone)]
pub struct BytesCodec;

impl<I> Encoder<I> for BytesCodec where I: Into<Bytes> {
    type Error = io::Error;
    fn encode(&mut self, item: I, dst: &mut BytesMut) -> Result<(), Self::Error> {
        let item = item.into();
        dst.reserve(item.len());
        dst.put(item);
        Ok(())
    }
}

impl Decoder for BytesCodec {
    type Item = BytesMut;
    type Error = io::Error;
    fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {
        if src.is_empty() {
            Ok(None)
        } else {
            let len = src.len();
            Ok(Some(src.split_to(len)))
        }
    }
}

#[pin_project]
struct FakeSocket<F> {
    #[pin]
    inner: F,
}

impl<F: Future> AsyncRead for FakeSocket<F> {
    fn poll_read(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        _buf: &mut [u8],
    ) -> Poll<io::Result<usize>> {
        self.project().inner.poll(cx).map(|_| Ok(0))
    }
}

impl<F> AsyncWrite for FakeSocket<F> {
    fn poll_write( self: Pin<&mut Self>, _cx: &mut Context<'_>, _buf: &[u8]) -> Poll<io::Result<usize>> { unimplemented!() }
    fn poll_flush(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<io::Result<()>> { unimplemented!() }
    fn poll_shutdown(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<io::Result<()>> { unimplemented!() }
}

// SECTION 2: PATCHED CODE

const LW: usize = 1024;
const HW: usize = 8 * 1024;

bitflags! {
    struct Flags: u8 {
        const EOF = 0b0001;
        const READABLE = 0b0010;
    }
}

#[pin_project]
pub struct Framed<T, U> {
    #[pin]
    io: T,
    codec: U,
    flags: Flags,
    read_buf: BytesMut,
    write_buf: BytesMut,
}

impl<T, U> Framed<T, U>
where
    T: AsyncRead + AsyncWrite,
    U: Decoder,
{
    pub fn new(io: T, codec: U) -> Framed<T, U> {
        Framed {
            io,
            codec,
            flags: Flags::empty(),
            read_buf: BytesMut::with_capacity(HW),
            write_buf: BytesMut::with_capacity(HW),
        }
    }
}

impl<T, U> Framed<T, U> {
    pub fn next_item(
        mut self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Result<<U as Decoder>::Item, U::Error>>>
    where
        T: AsyncRead,
        U: Decoder,
    {
        loop {
            let mut this = self.as_mut().project();
            if this.flags.contains(Flags::READABLE) {
                if this.flags.contains(Flags::EOF) {
                    return match this.codec.decode_eof(this.read_buf) {
                        Ok(Some(frame)) => Poll::Ready(Some(Ok(frame))),
                        Ok(None) => Poll::Ready(None),
                        Err(e) => Poll::Ready(Some(Err(e))),
                    };
                }
                if let Ok(Some(frame)) = this.codec.decode(this.read_buf) {
                    return Poll::Ready(Some(Ok(frame)));
                }
                this.flags.remove(Flags::READABLE);
            }

            debug_assert!(!this.flags.contains(Flags::EOF));
            let remaining = this.read_buf.capacity() - this.read_buf.len();
            if remaining < LW {
                this.read_buf.reserve(HW - remaining)
            }
            let cnt = match this.io.as_mut().poll_read_buf(cx, this.read_buf) {
                Poll::Pending => return Poll::Pending,
                Poll::Ready(Err(e)) => return Poll::Ready(Some(Err(e.into()))),
                Poll::Ready(Ok(cnt)) => cnt,
            };
            if cnt == 0 {
                this.flags.insert(Flags::EOF);
            }
            this.flags.insert(Flags::READABLE);
        }
    }
}

// SECTION 3: PROOF-OF-CONCEPT (UNCHANGED from vulnerable version)
fn main() {
    let (wake_tx, wake_rx) = oneshot::channel::<()>();
    let (result_tx, mut result_rx) = oneshot::channel::<u64>();

    const ORIGINAL_PATTERN: u64 = 0xFEEDBEEF_CAFEBABE;
    const CORRUPTING_BYTE: u8 = 0x41; // 'A'
    const CORRUPTING_PATTERN: u64 = u64::from_ne_bytes([CORRUPTING_BYTE; 8]);
    const CORRUPTING_BYTE_ARRAY: [u8; 32] = [CORRUPTING_BYTE; 32];

    let mut framed: Result<_, [u8; 32]> = Ok(Framed::new(
        FakeSocket {
            inner: async move {
                // Data on the stack that will become dangling.
                let original_data = ORIGINAL_PATTERN.to_ne_bytes();
                let y_ptr = &original_data as *const _ as *const u64;

                // Wait until the Framed object is moved.
                let _ = wake_rx.await;

                // UAF: Read from the dangling pointer.
                // This reads the bytes from CORRUPTING_BYTE_ARRAY.
                let corrupted_value = unsafe { *y_ptr };
                let _ = result_tx.send(corrupted_value);
            },
        },
        BytesCodec,
    ));

    let waker = noop_waker();
    let mut context = Context::from_waker(&waker);

    // Poll once to create the stack frame and pointer `y_ptr`.
    let _ = framed.as_mut().unwrap().next_item(&mut context);

    // Move `Framed`, dropping its internal future's stack and replacing it.
    let mut moved_framed = mem::replace(&mut framed, Err(CORRUPTING_BYTE_ARRAY)).unwrap();

    // Wake the (now dangling) future.
    wake_tx.send(()).unwrap();

    // Poll again to execute the UAF read.
    let _ = moved_framed.next_item(&mut context);

    // Check the result using a non-blocking method.
    let value_after_uaf = result_rx
        .try_recv()
        .expect("Receiver should not be canceled")
        .expect("Future should have sent a value");

    println!("Original pattern:    {:#x}", ORIGINAL_PATTERN);
    println!("Corrupting pattern:  {:#x}", CORRUPTING_PATTERN);
    println!("Value read after UAF:{:#x}", value_after_uaf);
    assert_eq!(
        value_after_uaf, CORRUPTING_PATTERN,
        "UAF read should yield the corrupting pattern."
    );
    assert_ne!(
        value_after_uaf, ORIGINAL_PATTERN,
        "Corrupted value should not be the original value."
    );
}