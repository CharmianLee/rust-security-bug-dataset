// SECTION 1: MINIMAL DEPENDENCIES

use std::mem;
use std::slice;

macro_rules! copy {
    ($src:expr, $src_start:expr, $dest:expr, $dest_start:expr, $len:expr) => {
        (&mut $dest[$dest_start..$dest_start+$len]).copy_from_slice(&$src[$src_start..$src_start+$len])
    };
}

#[derive(Clone, Debug)]
pub struct Buffer {
    array: Box<[u8]>,
    head: usize,
    len: usize,
}

impl Buffer {
    pub fn from<B: Into<Vec<u8>>>(bytes: B) -> Self {
        let bytes = bytes.into();
        let len = bytes.len();

        Self {
            array: bytes.into_boxed_slice(),
            head: 0,
            len: len,
        }
    }

    #[inline]
    pub fn capacity(&self) -> usize {
        self.array.len()
    }

    pub fn copy_to(&self, dest: &mut [u8]) -> usize {
        let count = dest.len().min(self.len);
        if count == 0 {
            return 0;
        }
        let tail = self.offset(count);
        if tail <= self.head {
            let head_len = self.capacity() - self.head;
            copy!(self.array, self.head, dest, 0, head_len);
            copy!(self.array, 0, dest, head_len, tail);
        } else {
            copy!(self.array, self.head, dest, 0, count);
        }
        count
    }

    fn offset(&self, index: usize) -> usize {
        let mut offset = self.head + index;
        if offset >= self.capacity() {
            offset -= self.capacity();
        }
        offset
    }

    fn allocate(size: usize) -> Box<[u8]> {
        unsafe {
            let mut vec = Vec::<u8>::with_capacity(size);
            let slice = slice::from_raw_parts_mut(vec.as_mut_ptr(), vec.capacity());
            mem::forget(vec);
            Box::from_raw(slice)
        }
    }
}

// SECTION 2: PATCHED CODE

impl From<Buffer> for Vec<u8> {
    fn from(buffer: Buffer) -> Vec<u8> {
        let mut slice = Buffer::allocate(buffer.len);
        let len = buffer.copy_to(&mut slice);

        unsafe {
            let vec = Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len());
            // The fix: Prevent the Box `slice` from being dropped,
            // thus transferring memory ownership to the new `vec`.
            mem::forget(slice);
            vec
        }
    }
}


// SECTION 3: VERIFICATION OF THE PATCH
fn main() {
    // 1. Setup vulnerable object with initial data.
    let original_data = b"this memory will be freed".to_vec();
    let buffer = Buffer::from(original_data.clone());

    // 2. Trigger BUG: Convert Buffer to Vec.
    // The `buffer` is consumed. Inside `from`, a temporary Box (`slice`) is created,
    // The Box is then dropped, `uaf_vec` now holds a dangling pointer.
    let uaf_vec = Vec::from(buffer);

    // 3. Force memory allocation to overwrite the freed region.
    let new_data = vec![0xAA; original_data.len()];

    // 4. Verify UAF. Accessing `uaf_vec` reads from the dangling pointer.
    println!("Data in UAF vector: {:?}", uaf_vec);
    println!("Data that overwrote memory: {:?}", new_data);
    assert_eq!(uaf_vec, original_data, "UAF triggered: memory content has changed!");
    println!("Data is still valid, UAF not triggered as expected.");
}